630 Pseudocode:

Upon Receipt of MSG type:

PROBE:
 compare the sender's ID to current previous-hop
 IF sender's ID > current previous-hop:
 	respond with PROBE ACK
 	update current previous-hop to be this new node
 	(we will no longer accept messages from the old previous hop)
 ELSE sender's ID < current previous-hop (it's not the right prev-hop):
 	respond with PROBE NACK
 	
 	NOTE: it's not the absolute ID but the correct order so use indices into an array

PROBE ACK:
	Is this acknowledging the CURRENT potential next-hop that i'm waiting on?
	(DO WE CARe? should we take a stale ack if it's better, even though it was late?)
	if so, yay! set my next-hop to be my acknowledger
	otherwise...
		? ignore


PROBE NACK:
	was this the one I was waiting on?
		bummer! on to the next one
	wasn't waiting on?
		don't care, ignore and do whatever I was already going to do


ELECTION:
	if this election is valid, my token isn't
	was this an election ID that I was timing? 
		if so, reset timer
		KC: reset timer needed? 
		(depends on the timing approach)
	myID > candidate:
		set candidate field with my ID in it
		you are now responsible for making sure this comes back around the ring
			(so set a timer)
		forward message
	myID < candidate:
		just forward it
	myID == candidate:
		you're elected!
		send an elected message

ELECTED:
	was this an elected message that I was timing?
		if so, reset timer
		KC: needed? or just kill it?
	set new leader ID to the elected candidate
	if I AM the elected one:
		create a new token msg???
		KC: maybe need to send the token ID with the elected message, otherwise
		how do we distinguish between elections (and subsequently created tokens)
		that end up with the same node elected (all we know is to wait for a token
		from node X, but if node X was the previous elected node, their old stale
		token could be floating around still)(Reza doesn't specify this but...)
		NOPE YOU'RE WRONGGGG

TOKEN:
	send pending message m (pending = unsent up to current timestamp)
	WAIT for it to come back before sending m+1
	if timeout:
		...
		start discovery process...
			after your next hop is found, wait random time, 
			IF no other election has been started/seen:
				start a new election
		do I have to resend my message?
		KC: yes, some nodes may not have seen it
	if m comes back around:
		if still have messages to send:
			send m + 1
		no more messages?
			forward token
			
KC: POST:
	was this a post I sent?
		if yes, send m+1 
			reset tmer
			start timer
		if no, forward to next node
		
Other things for consideration:
timeout estimate should be updated for every post message (at least?)
2x turnaround time

CLIENT NEEDS:
it's port num
port range (in an array)
prev hop
next hop
join and leave times
list of messages with times
current leader
current token ID? (maybe not? should the election process be enough to indicate validity of tokens?)
queue of pending times/msgIDs that you need to see OR a "last seen" global time
post messages that need to come around before we can send m+1
current timeout value
recent RTT
current elapsed time
PORTID : SEQNO mapping??

OUTPUT FORMATS:
[time]: next hop is changed to client [port#] - when this client detects a better (or its first) next hop
[time]: previous hop is changed to client [port#] - when this client is contacted by client [port#] which is a better option (has a closer port number) than the current one to be this client's previous hop.
[time]: started election, send election message to client [port#] - when this client starts an election and sends the first message to next hop client [port#]
[time]: relayed election message, replaced leader - when this client send the election message to next hop and replaces the suggested leader in the message to itself
[time]: relayed election message, leader: client [port#] - when this client relays an election message that contains client [port#] as the leader
[time]: leader selected - when this client is selected as the leader
[time]: new token generated [#RandomTokenID] - this should be reported by the leader when it generates a token with token ID of #RandomTokenID
[time]: token [#RandomTokenID] was sent to client [port#] - when this client sends the token to next hop node which is client [port#]
[time]: token [#RandomTokenID] was received - when this node receives the token
[time]: post "CCCCC" was sent - indicating that this client has posted a message with the content of CCCC
[time]: post "CCCCC" from client [port#] was relayed - indicating that this client receives a post that was original sent by client [port#] with the content of CCCC and relayed it to its next hop
[time]: post "CCCCC" was delivered to all successfully - indicating that this post by this client was delivered back to this client after going through the entire ring
[time]: ring is broken - when this client detects that the ring is broken
		
